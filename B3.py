from typing import Any
import pandas as pd

def total_weight(df1: pd.DataFrame, df2: pd.DataFrame) -> float:
    """
    Нужно посчитать общий вес проданных товаров.
    Веса товаров, которые продаются наразвес, нужно просто сложить,
    а у товаров, которые продаются поштучно, веса нужно взять из
    отдельной таблицы.

    Например,
       id  product   weight   pieces
    0  432 apple     3.2      <NA>
    1  433 orange    1.3      <NA>
    2  444 apple     5.4      <NA>
    3  447 yoghurt   <NA>     4
    4  447 bread     <NA>     3

       product   weight
    0  yoghurt   0.1  
    1  bread     0.3  

    3.2 + 1.3 + 5.4+ 4*0.1 + 3*0.3 = 11.2

    Исходные датафреймы должны остаться неизменными.
    """

    return

def set_index_value(df: pd.DataFrame, i: int, val: Any) -> pd.DataFrame:
    """
    Изменяет i-е значение индекса датафрейма на заданное значение. Например,
    для такого датафрейма

                     FGE       FFI       FRA    FARCAD    FCOCAD                                                        
    date
    2020-12-31       NaN       NaN       NaN       NaN       NaN
    2021-12-31  0.137961 -0.040112  0.098811  0.062196  0.088000
    2022-12-31 -0.142319 -0.090379  0.068276  0.102470  0.095588
    2022-12-31  0.038630 -0.035256  0.067030  0.044813  0.037752

    set_index_value(df, -1, '2023-12-31') изменит '2022-12-31' на '2023-12-31'.

    Возвращает новый датафрейм (не трогает исходный).
    """

    return

def count_low_high(df: pd.DataFrame) -> pd.DataFrame:
    """
    Дан датафрейм вида

    df = pd.DataFrame({
        'col1': ['a', 'a', 'b', 'b', 'b', 'c', 'c', 'c', 'c', 'a'],
        'col2': [1,2,1,4,5,6,6,6,9,1],
        'col3': ['LOW', 'HIGH', 'LOW','LOW','HIGH', 'LOW', 'HIGH', 'LOW', 'HIGH', 'HIGH'],
    })

    Для каждого значения col1 необходимо посчитать количество уникальных значений в столбце
    col2 если col3 равен LOW, и сохранить это значение в новом столбце 'low_count'. 
    Аналогично для HIGH и high_count.

    Так для датафрейма, приведённого выше, результат будет 

    pd.DataFrame({
        ...
        'low-count': [1, 1, 2, 2, 2, 1, 1, 1, 1, 1],
        'high-count': [2, 2, 1, 1, 1, 2, 2, 2, 2, 2],
    })

    Возвращает новый датафрейм (не трогает исходный).
    """

    return 


def unroll(df: pd.DataFrame) -> pd.DataFrame:
    """
    В столбце C датафрейма df находятся числа, разделённые запятыми. 

      A       B            C       
    32011     X     [147, 140, 133]
    32012     Y     [134, 146]
    32013     Z     [175, 168, 161, 154]

    Необходимо сформировать из этих чисел стоблец D, так чтобы в столбце B осталось исходное значение
    из соответствуеющей строки, а счётчик в стоблце A автоматически увеличивался:

      A       B      D       
    32011     X     147
    32012     X     140
    32013     X     133
    32012     Y     134
    32013     Y     146
    32013     Z     175
    32014     Z     168
    32015     Z     161
    32016     Z     154
    """
    return    